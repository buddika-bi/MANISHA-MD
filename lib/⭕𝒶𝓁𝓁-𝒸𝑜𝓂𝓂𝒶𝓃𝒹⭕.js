const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, runtime, sleep, fetchJson, jsonformat} = require('./functions')
const { cmd, commands } = require('./command')
const config = require('../config');
const axios = require("axios")
const os = require("os")
const fs = require('fs-extra');
const path = require('path');
const fetch = require('node-fetch');
const cheerio = require("cheerio");
const { igdl } = require("ruhend-scraper");
const { ytsearch } = require('@dark-yasiya/yt-dl.js');
//=============google trslart===========
const googleTTS = require('google-tts-api')
//========================
//============ YT SEARCH=======
const dl = require('@bochilteam/scraper')  
const l = console.log
const ytdl = require('yt-search');
var videotime = 60000 // 1000 min
//====================== AI API ================
const GEMINI_API_KEY = config.GEMINI_API_KEY;  //REPLACE WITH YOUR API KEY OF GEMINI
const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GEMINI_API_KEY}`;
//============================================
//========== MOVIE API ==============
const API_URL = "https://api.skymansion.site/movies-dl/search";
const DOWNLOAD_URL = "https://api.skymansion.site/movies-dl/download";
const API_KEY = config.MOVIE_API_KEY;

//===================DOWNLOAD COMMAND======================
// song download 

cmd({ 
    pattern: "song", 
    alias: ["song"], 
    react: "üé∂", 
    desc: "Download YouTube song", 
    category: "download", 
    use: '.song <query>', 
    filename: __filename 
}, async (conn, mek, m, { from, sender, reply, q }) => { 
    try {
        if (!q) return reply("Please provide a song name or YouTube link.");

        const yt = await ytsearch(q);
        if (!yt.results.length) return reply("No results found!");

        const song = yt.results[0];
        const apiUrl = `https://apis.davidcyriltech.my.id/youtube/mp3?url=${encodeURIComponent(song.url)}`;
        
        const res = await fetch(apiUrl);
        const data = await res.json();

        if (!data?.result?.downloadUrl) return reply("Download failed. Try again later.");

    await conn.sendMessage(from, {
    audio: { url: data.result.downloadUrl },
    mimetype: "audio/mpeg",
    fileName: `${song.title}.mp3`,
    contextInfo: {
        externalAdReply: {
            title: song.title.length > 25 ? `${song.title.substring(0, 22)}...` : song.title,
            body: "FOR MORE UPDATE FOLLOW OUR CHAHNAL",
            mediaType: 1,
            thumbnailUrl: song.thumbnail.replace('default.jpg', 'hqdefault.jpg'),
            sourceUrl: 'https://whatsapp.com/channel/0029VbAdMtMGk1G1R9Yg2L3x',
            mediaUrl: 'https://whatsapp.com/channel/0029VbAdMtMGk1G1R9Yg2L3x',
            showAdAttribution: true,
            renderLargerThumbnail: true
        }
    }
}, { quoted: mek });

    } catch (error) {
        console.error(error);
        reply("An error occurred. Please try again.");
    }
});

//video download

cmd({ 
    pattern: "video", 
    alias: ["video"], 
    react: "üé•", 
    desc: "Download YouTube video", 
    category: "download", 
    use: '.video < YT URL OR NAME >', 
    filename: __filename 
}, async (conn, mek, m, { from, prefix, quoted, q, reply }) => { 
    try { 
        if (!q) return await reply("PROVIDE URL OR NAME");
        
        const yt = await ytsearch(q);
        if (yt.results.length < 1) return reply("No results found!");
        
        let yts = yt.results[0];  
        let apiUrl = `https://apis.davidcyriltech.my.id/download/ytmp4?url=${encodeURIComponent(yts.url)}`;
        
        let response = await fetch(apiUrl);
        let data = await response.json();
        
        if (data.status !== 200 || !data.success || !data.result.download_url) {
            return reply("Failed to fetch the video. Please try again later.");
        }

        let ytmsg = `‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚óè‚ñ∫
 *‚≠ï·¥ç·¥Ä…¥…™Íú± ú·¥Ä-·¥ç·¥Ö ·¥†…™·¥Ö·¥á·¥è ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö‚≠ï*
 
 *‚≠ï·¥õ…™·¥õ ü·¥á:* ${yts.title}
 *‚≠ï·¥Ö·¥ú Ä·¥Ä·¥õ…™·¥è…¥:* ${yts.timestamp}
 *‚≠ï·¥†…™·¥°·¥áÍú±:* ${yts.views}
 *‚≠ï·¥Ä·¥ú·¥õ ú·¥è Ä:* ${yts.author.name}
 *‚≠ï ü…™…¥·¥ã:* ${yts.url}
 
> *·¥Ñ Ä·¥á·¥Ä·¥õ·¥á·¥Ö  ô è ·¥ç·¥Ä…¥…™Íú± ú·¥Ä ·¥Ñ·¥è·¥Ö·¥á Ä*
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚óè‚ñ∫`;

        // Send video directly with caption
        await conn.sendMessage(
            from, 
            { 
                video: { url: data.result.download_url }, 
                caption: ytmsg,
                mimetype: "video/mp4"
            }, 
            { quoted: mek }
        );

    } catch (e) {
        console.log(e);
        reply("An error occurred. Please try again later.");
    }
});


const apilink = 'https://www.dark-yasiya-api.site'; // DO NOT CHANGE
cmd({
    pattern: "xvideos",
    alias: ["xvdl", "xvdown"],
    react: "üîû",
    desc: "Download xvideo.com porn video",
    category: "download",
    use: '.xvideo < search text >',
    filename: __filename
},
async (conn, mek, m, { from, quoted, reply, q }) => {
    try {
        if (!q) return await reply("Please provide a search term! üîç");

        const xv_list = await fetchJson(`${apilink}/search/xvideo?q=${encodeURIComponent(q)}`);

        if (!xv_list?.result || xv_list.result.length === 0) {
            return await reply("No results found! ‚ùå");
        }

        const video_url = xv_list.result[0].url;
        const xv_info = await fetchJson(`${apilink}/download/xvideo?url=${video_url}`);

        const msg = `‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚óè‚ñ∫
        *MANISHA-MD XVIDEO DOWNLOADER*
        
        ‚Ä¢ *litle* - ${xv_info.result.title}
        ‚Ä¢ *views* - ${xv_info.result.views}
        ‚Ä¢ *like* - ${xv_info.result.like}
        ‚Ä¢ *deslike* - ${xv_info.result.deslike}
        ‚Ä¢ *size* - ${xv_info.result.size}
        
        > *·¥Ñ Ä·¥á·¥Ä·¥õ·¥á·¥Ö  ô è ·¥ç·¥Ä…¥…™Íú± ú·¥Ä ·¥Ñ·¥è·¥Ö·¥á Ä*
        ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚óè‚ñ∫`;

        // Thumbnail + Info
        await conn.sendMessage(from, {
            image: { url: xv_info.result.dl_link },
            mimetype: "image/jpeg",
            caption: msg
        }, { quoted: mek });

        // Actual Video
        const fileName = xv_info.result.title.endsWith('.mp4') ? xv_info.result.title : xv_info.result.title + '.mp4';

        await conn.sendMessage(from, {
            document: { url: xv_info.result.dl_link },
            mimetype: "video/mp4",
            fileName: fileName
        }, { quoted: mek });

    } catch (error) {
        console.log("üö® Error in xvideo command:", error);
        await reply("Nothing can be downloaded. ‚ùó\n\nError: " + error.message);
    }
});

cmd({
  pattern: "twitter",
  alias: ["tweet", "twdl"],
  desc: "Download Twitter videos",
  category: "download",
  filename: __filename
}, async (conn, m, store, {
  from,
  quoted,
  q,
  reply
}) => {
  try {
    if (!q || !q.startsWith("https://")) {
      return conn.sendMessage(from, { text: "‚ùå Please provide a valid Twitter URL." }, { quoted: m });
    }

    await conn.sendMessage(from, {
      react: { text: '‚è≥', key: m.key }
    });

    const response = await axios.get(`https://www.dark-yasiya-api.site/download/twitter?url=${q}`);
    const data = response.data;

    if (!data || !data.status || !data.result) {
      return reply("‚ö†Ô∏è Failed to retrieve Twitter video. Please check the link and try again.");
    }

    const { desc, thumb, video_sd, video_hd } = data.result;

    const caption = `*‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚óè‚ñ∫*
    > *‚≠ï·¥õ·¥°…™·¥õ·¥è Ä ·¥†…™·¥Ö·¥á·¥è ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö‚≠ï*
    
    *‚≠ï·¥Ö·¥áÍú±·¥Ñ Ä…™·¥ò·¥õ…™·¥è…¥:* ${desc || "No description"}
    
    *üé¨·¥†…™·¥Ö·¥á·¥è ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö ·¥è·¥ò·¥õ…™·¥è…¥Íú±*
    *1*‚ô¶Ô∏è*SD Quality*
    *2*‚ô¶Ô∏è*HD Quality*
    
    *üéµ·¥Ä·¥ú·¥Ö…™·¥è ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö ·¥è·¥ò·¥õ…™·¥è…¥Íú±*
    *3*‚ô¶Ô∏è*Audio*
    *4*‚ô¶Ô∏è*Document*
    *5*‚ô¶Ô∏è*Voice*
    *‚≠ï Ä·¥á·¥ò ü è ·¥°…™·¥õ ú ·¥õ ú·¥á …¥·¥ú·¥ç ô·¥á Ä*
    *‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚óè‚ñ∫*`;

    const sentMsg = await conn.sendMessage(from, {
      image: { url: thumb },
      caption: caption
    }, { quoted: m });

    const messageID = sentMsg.key.id;

    conn.ev.on("messages.upsert", async (msgData) => {
      const receivedMsg = msgData.messages[0];
      if (!receivedMsg.message) return;

      const receivedText = receivedMsg.message.conversation || receivedMsg.message.extendedTextMessage?.text;
      const senderID = receivedMsg.key.remoteJid;
      const isReplyToBot = receivedMsg.message.extendedTextMessage?.contextInfo?.stanzaId === messageID;

      if (isReplyToBot) {
        await conn.sendMessage(senderID, {
          react: { text: '‚¨áÔ∏è', key: receivedMsg.key }
        });

        switch (receivedText) {
          case "1":
            await conn.sendMessage(senderID, {
              video: { url: video_sd },
              caption: "üì• *Downloaded in SD Quality*"
            }, { quoted: receivedMsg });
            break;

          case "2":
            await conn.sendMessage(senderID, {
              video: { url: video_hd },
              caption: "üì• *Downloaded in HD Quality*"
            }, { quoted: receivedMsg });
            break;

          case "3":
            await conn.sendMessage(senderID, {
              audio: { url: video_sd },
              mimetype: "audio/mpeg"
            }, { quoted: receivedMsg });
            break;

          case "4":
            await conn.sendMessage(senderID, {
              document: { url: video_sd },
              mimetype: "audio/mpeg",
              fileName: "Twitter_Audio.mp3",
              caption: "üì• *Audio Downloaded as Document*"
            }, { quoted: receivedMsg });
            break;

          case "5":
            await conn.sendMessage(senderID, {
              audio: { url: video_sd },
              mimetype: "audio/mp4",
              ptt: true
            }, { quoted: receivedMsg });
            break;

          default:
            reply("‚ùå Invalid option! Please reply with 1, 2, 3, 4, or 5.");
        }
      }
    });

  } catch (error) {
    console.error("Error:", error);
    reply("‚ùå An error occurred while processing your request. Please try again.");
  }
});

// G-Drive-DL

cmd({
  pattern: "gdrive",
  desc: "Download Google Drive files.",
  react: "üåê",
  category: "download",
  filename: __filename
}, async (conn, m, store, {
  from,
  quoted,
  q,
  reply
}) => {
  try {
    if (!q) {
      return reply("‚ùå Please provide a valid Google Drive link.");
    }

    await conn.sendMessage(from, { react: { text: "‚¨áÔ∏è", key: m.key } });

    const apiUrl = `https://api.fgmods.xyz/api/downloader/gdrive?url=${q}&apikey=mnp3grlZ`;
    const response = await axios.get(apiUrl);
    const downloadUrl = response.data.result.downloadUrl;

    if (downloadUrl) {
      await conn.sendMessage(from, { react: { text: "‚¨ÜÔ∏è", key: m.key } });

      await conn.sendMessage(from, {
        document: { url: downloadUrl },
        mimetype: response.data.result.mimetype,
        fileName: response.data.result.fileName,
        caption: "> *·¥Ñ Ä·¥á·¥Ä·¥õ·¥á·¥Ö  ô è ·¥ç·¥Ä…¥…™Íú± ú·¥Ä ·¥Ñ·¥è·¥Ö·¥á Ä*"
      }, { quoted: m });

      await conn.sendMessage(from, { react: { text: "‚úÖ", key: m.key } });
    } else {
      return reply("‚ö†Ô∏è No download URL found. Please check the link and try again.");
    }
  } catch (error) {
    console.error("Error:", error);
    reply("‚ùå An error occurred while fetching the Google Drive file. Please try again.");
  }
}); 


cmd({
    pattern: "tiktok",
    alias: ["ttdl", "tt", "tiktokdl"],
    desc: "Download TikTok video without watermark",
    category: "download",
    react: "üß®",
    filename: __filename
},
async (conn, mek, m, { from, args, q, reply }) => {
    try {
        if (!q) return reply("Please provide a TikTok video link.");
        if (!q.includes("tiktok.com")) return reply("Invalid TikTok link.");
        
        reply("Downloading video, please wait...");
        
        const apiUrl = `https://delirius-apiofc.vercel.app/download/tiktok?url=${q}`;
        const { data } = await axios.get(apiUrl);
        
        if (!data.status || !data.data) return reply("Failed to fetch TikTok video.");
        
        const { title, like, comment, share, author, meta } = data.data;
        const videoUrl = meta.media.find(v => v.type === "video").org;
        
        const caption = `‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚óè‚ñ∫
        > *‚≠ï·¥õ…™·¥ã·¥õ·¥è·¥ã ·¥†…™·¥Ö·¥á·¥è ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö‚≠ï* 
        
        *‚≠ï·¥úÍú±·¥Ä Ä:* ${author.nickname} (@${author.username})
        *‚≠ï·¥õ…™·¥õ ü·¥á:* ${title}
        *‚≠ï ü…™·¥ã·¥á:* ${like}
        *‚≠ï·¥Ñ·¥è·¥ç·¥ç·¥á…¥·¥õ:* ${comment}
        *‚≠ïÍú± ú·¥Ä Ä·¥á:* ${share}
        > *·¥Ñ Ä·¥á·¥Ä·¥õ·¥á·¥Ö  ô è ·¥ç·¥Ä…¥…™Íú± ú·¥Ä ·¥Ñ·¥è·¥Ö·¥á Ä*
        ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚óè‚ñ∫`;
        
        await conn.sendMessage(from, {
            video: { url: videoUrl },
            caption: caption,
            contextInfo: { mentionedJid: [m.sender] }
        }, { quoted: mek });
        
    } catch (e) {
        console.error("Error in TikTok downloader command:", e);
        reply(`An error occurred: ${e.message}`);
    }
});

cmd({
  pattern: "ig",
  alias: ["insta", "Instagram","ig"],
  desc: "To download Instagram videos.",
  react: "üé•",
  category: "download",
  filename: __filename
}, async (conn, m, store, { from, q, reply }) => {
  try {
    if (!q || !q.startsWith("http")) {
      return reply("‚ùå Please provide a valid Instagram link.");
    }

    await conn.sendMessage(from, {
      react: { text: "‚è≥", key: m.key }
    });

    const response = await axios.get(`https://api.davidcyriltech.my.id/instagram?url=${q}`);
    const data = response.data;

    if (!data || data.status !== 200 || !data.downloadUrl) {
      return reply("‚ö†Ô∏è Failed to fetch Instagram video. Please check the link and try again.");
    }

    await conn.sendMessage(from, {
      video: { url: data.downloadUrl },
      mimetype: "video/mp4",
      caption: "üì• *DOWNLOAD SUCCESSFULLY!*"
    }, { quoted: m });

  } catch (error) {
    console.error("Error:", error);
    reply("‚ùå An error occurred while processing your request. Please try again.");
  }
});

// MediaFire-dl

cmd({
  pattern: "mediafire",
  alias: ["mfire","mf"],
  desc: "To download MediaFire files.",
  react: "üçø",
  category: "download",
  filename: __filename
}, async (conn, m, store, {
  from,
  quoted,
  q,
  reply
}) => {
  try {
    if (!q) {
      return reply("‚ùå Please provide a valid MediaFire link.");
    }

    await conn.sendMessage(from, {
      react: { text: "‚è≥", key: m.key }
    });

    const response = await axios.get(`https://www.dark-yasiya-api.site/download/mfire?url=${q}`);
    const data = response.data;

    if (!data || !data.status || !data.result || !data.result.dl_link) {
      return reply("‚ö†Ô∏è Failed to fetch MediaFire download link. Ensure the link is valid and public.");
    }

    const { dl_link, fileName, fileType } = data.result;
    const file_name = fileName || "mediafire_download";
    const mime_type = fileType || "application/octet-stream";

    await conn.sendMessage(from, {
      react: { text: "‚¨ÜÔ∏è", key: m.key }
    });

    const caption = `‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚óè‚ñ∫
    > *‚≠ï·¥ç·¥á·¥á·¥Ö…™·¥ÄÍú∞…™ Ä·¥á Íú∞…™ ü·¥á ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö‚≠ï*
    
    *‚≠ïÍú∞…™ ü·¥á …¥·¥Ä·¥ç·¥á:* ${file_name}
    *‚≠ïÍú∞…™ ü·¥á ·¥õ è·¥ò·¥á:* ${mime_type}
    
    > *·¥Ñ Ä·¥á·¥Ä·¥õ·¥á·¥Ö  ô è ·¥ç·¥Ä…¥…™Íú± ú·¥Ä ·¥Ñ·¥è·¥Ö·¥á Ä*
    ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚óè‚ñ∫`;
    await conn.sendMessage(from, {
      document: { url: dl_link },
      mimetype: mime_type,
      fileName: file_name,
      caption: caption
    }, { quoted: m });

  } catch (error) {
    console.error("Error:", error);
    reply("‚ùå An error occurred while processing your request. Please try again.");
  }
});
        

cmd({
  pattern: "apk",
  desc: "Download APK from Aptoide.",
  category: "download",
  filename: __filename
}, async (conn, m, store, {
  from,
  quoted,
  q,
  reply
}) => {
  try {
    if (!q) {
      return reply("‚ùå Please provide an app name to search.");
    }

    await conn.sendMessage(from, { react: { text: "‚è≥", key: m.key } });

    const apiUrl = `http://ws75.aptoide.com/api/7/apps/search/query=${q}/limit=1`;
    const response = await axios.get(apiUrl);
    const data = response.data;

    if (!data || !data.datalist || !data.datalist.list.length) {
      return reply("‚ö†Ô∏è No results found for the given app name.");
    }

    const app = data.datalist.list[0];
    const appSize = (app.size / 1048576).toFixed(2); // Convert bytes to MB

    const caption = `‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚óè‚ñ∫
    > *‚≠ï·¥Ä·¥ò·¥ã ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö‚≠ï*
    
    *‚≠ï…¥·¥Ä·¥ç·¥á:* ${app.name}
    *‚≠ïÍú±…™·¥¢·¥á:* ${appSize}·¥ç ô
    *‚≠ï·¥ò·¥Ä·¥Ñ·¥ã·¥Ä…¢·¥á:* ${app.package}
    *‚≠ï·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥á·¥Ö:* ${app.updated}
    *‚≠ï·¥Ö·¥á·¥†·¥á·¥ò ü·¥è·¥ò·¥á Ä:* ${app.developer.name}
    
> *·¥Ñ Ä·¥á·¥Ä·¥õ·¥á·¥Ö  ô è ·¥ç·¥Ä…¥…™Íú± ú·¥Ä ·¥Ñ·¥è·¥Ö·¥á Ä*
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚óè‚ñ∫`;

    await conn.sendMessage(from, { react: { text: "‚¨ÜÔ∏è", key: m.key } });

    await conn.sendMessage(from, {
      document: { url: app.file.path_alt },
      fileName: `${app.name}.apk`,
      mimetype: "application/vnd.android.package-archive",
      caption: caption
    }, { quoted: m });

    await conn.sendMessage(from, { react: { text: "‚úÖ", key: m.key } });

  } catch (error) {
    console.error("Error:", error);
    reply("‚ùå An error occurred while fetching the APK. Please try again.");
  }
});
              
cmd({
    pattern: "img",
    alias: ["image", "googleimage", "searchimg"],
    react: "üñºÔ∏è",
    desc: "Search and download Google images",
    category: "download",
    use: ".img <keywords>",
    filename: __filename
}, async (conn, mek, m, { reply, args, from }) => {
    try {
        const query = args.join(" ");
        if (!query) {
            return reply(" Please provide a search query\nExample: .img dogs");
        }

        await reply(`üîç Searching images for "${query}"...`);

        const url = `https://apis.davidcyriltech.my.id/googleimage?query=${encodeURIComponent(query)}`;
        const response = await axios.get(url);

        // Validate response
        if (!response.data?.success || !response.data.results?.length) {
            return reply("‚ùå No images found. Try different keywords");
        }

        const results = response.data.results;
        // Get 5 random images
        const selectedImages = results
            .sort(() => 0.5 - Math.random())
            .slice(0, 5);

        for (const imageUrl of selectedImages) {
            await conn.sendMessage(
                from,
                { 
                    image: { url: imageUrl },
                    caption: `üì∑ Result for: ${query}\n *MANISHA-MD*`
                },
                { quoted: mek }
            );
            // Add delay between sends to avoid rate limiting
            await new Promise(resolve => setTimeout(resolve, 1000));
        }

    } catch (error) {
        console.error('Image Search Error:', error);
        reply(`‚ùå Error: ${error.message || "Failed to fetch images"}`);
    }
});

//===============MOVIE COMMAND=======================
cmd({
    pattern: "sinhalasub",
    alias: ["moviedl", "films"],
    react: 'üé¨',
    category: "movie",
    desc: "Search and download movies from PixelDrain",
    filename: __filename
}, async (conn, m, mek, { from, q, reply }) => {
    try {
        if (!q || q.trim() === '') return await reply('‚ùå Please provide a movie name! (e.g., Deadpool)');

        // Fetch movie search results
        const searchUrl = `${API_URL}?q=${encodeURIComponent(q)}&api_key=${API_KEY}`;
        let response = await fetchJson(searchUrl);

        if (!response || !response.SearchResult || !response.SearchResult.result.length) {
            return await reply(`‚ùå No results found for: *${q}*`);
        }

        const selectedMovie = response.SearchResult.result[0]; // Select first result
        const detailsUrl = `${DOWNLOAD_URL}/?id=${selectedMovie.id}&api_key=${API_KEY}`;
        let detailsResponse = await fetchJson(detailsUrl);

        if (!detailsResponse || !detailsResponse.downloadLinks || !detailsResponse.downloadLinks.result.links.driveLinks.length) {
            return await reply('‚ùå No PixelDrain download links found.');
        }

        // Select the 720p PixelDrain link
        const pixelDrainLinks = detailsResponse.downloadLinks.result.links.driveLinks;
        const selectedDownload = pixelDrainLinks.find(link => link.quality === "SD 480p");
        
        if (!selectedDownload || !selectedDownload.link.startsWith('http')) {
            return await reply('‚ùå No valid 480p PixelDrain link available.');
        }

        // Convert to direct download link
        const fileId = selectedDownload.link.split('/').pop();
        const directDownloadLink = `https://pixeldrain.com/api/file/${fileId}?download`;
        
        
        // Download movie
        const filePath = path.join(__dirname, `${selectedMovie.title}-480p.mp4`);
        const writer = fs.createWriteStream(filePath);
        
        const { data } = await axios({
            url: directDownloadLink,
            method: 'GET',
            responseType: 'stream'
        });

        data.pipe(writer);

        writer.on('finish', async () => {
            await conn.sendMessage(from, {
                document: fs.readFileSync(filePath),
                mimetype: 'video/mp4',
                fileName: `${selectedMovie.title}-480p.mp4`,
                caption: `üìå Quality: 480p\n‚úÖ *Download Complete!*\n\n> *·¥Ñ Ä·¥á·¥Ä·¥õ·¥á·¥Ö  ô è ·¥ç·¥Ä…¥…™Íú± ú·¥Ä ·¥Ñ·¥è·¥Ö·¥á Ä*`,
                quoted: mek 
            });
            fs.unlinkSync(filePath);
        });

        writer.on('error', async (err) => {
            console.error('Download Error:', err);
            await reply('‚ùå Failed to download movie. Please try again.');
        });
    } catch (error) {
        console.error('Error in movie command:', error);
        await reply('‚ùå Sorry, something went wrong. Please try again later.');
    }
});

//=============OWNER COMMAND =================

cmd({
    pattern: "restart",
    desc: "Restart the bot",
    react: "üîÑ",
    category: "owner",
    filename: __filename
},
async (conn, mek, m, {
    from, quoted, body, isCmd, command, args, q, isGroup, senderNumber, reply
}) => {
    try {
        // Get the bot owner's number dynamically from conn.user.id
        const botOwner = conn.user.id.split(":")[0]; // Extract the bot owner's number
        if (senderNumber !== botOwner) {
            return reply("Only the bot owner can use this command.");
        }

        const { exec } = require("child_process");
        reply("MANISHA-MD Restarting ‚è≥...");
        await sleep(1500);
        exec("pm2 restart all");
    } catch (e) {
        console.error(e);
        reply(`${e}`);
    }
});
//================MAIN COMMAND================

cmd({
      pattern: "owner",
      alias: ["owner"],
      desc: "Bot owner",
      category: "main",
      react: "üë®‚Äçüíª",
      filename: __filename
    },
    
    async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
    try{
          
          // Status message to be sent
          let desc = `‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚óè‚ñ∫
> *‚ô¶Ô∏è·¥è·¥°…¥·¥á Ä :* *94721551183 ...*
> *‚ô¶Ô∏è·¥° ú·¥Ä·¥õÍú±·¥Ä·¥ò·¥ò ·¥Ñ ú·¥Ä…¥…¥·¥á ü :* *https://whatsapp.com/channel/0029VbAdMtMGk1G1R9Yg2L3x*

> *·¥Ñ Ä·¥á·¥Ä·¥õ·¥á·¥Ö  ô è ·¥ç·¥Ä…¥…™Íú± ú·¥Ä ·¥Ñ·¥è·¥Ö·¥á Ä*
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚óè‚ñ∫`

          // Sending the image with caption
await conn.sendMessage(from,{image: {url: config.ALIVE_IMG},caption: desc},{quoted: mek });

      } catch (e) {
          console.error(e);
          reply(`*Error:* ${e.message}`);
      }
    });

cmd({
      pattern: "repo",
      alias: ["repo"],
      desc: "Bot github repo",
      category: "main",
      react: "üß®",
      filename: __filename
    },
    
    async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
    try{
          
          // Status message to be sent
          let desc = `‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚óè‚ñ∫
> *‚ô¶Ô∏è Ä·¥á·¥ò·¥è:* *https://github.com/manisha-Official18/MANISHA-MD*
> *‚ô¶Ô∏è·¥è·¥°…¥·¥á Ä :* *94721551183 ...*
> *‚ô¶Ô∏è·¥†·¥á ÄÍú±…™·¥è…¥ :* *1.0 ...*
> *‚ô¶Ô∏è·¥° ú·¥Ä·¥õÍú±·¥Ä·¥ò·¥ò ·¥Ñ ú·¥Ä…¥…¥·¥á ü : https://whatsapp.com/channel/0029VbAdMtMGk1G1R9Yg2L3x*

> *·¥Ñ Ä·¥á·¥Ä·¥õ·¥á·¥Ö  ô è ·¥ç·¥Ä…¥…™Íú± ú·¥Ä ·¥Ñ·¥è·¥Ö·¥á Ä*
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚óè‚ñ∫`

          // Sending the image with caption
await conn.sendMessage(from,{image: {url: config.ALIVE_IMG},caption: desc},{quoted: mek });

      } catch (e) {
          console.error(e);
          reply(`*Error:* ${e.message}`);
      }
    });

cmd({
      pattern: "alive",
      alias: ["online"],
      desc: "Chek Bot Alive",
      category: "main",
      react: "üëã",
      filename: __filename
    },
    
    async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
    try{
          
          // Status message to be sent
          let desc = `‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚óè‚ñ∫
> *‚ô¶Ô∏è·¥ò·¥è·¥°·¥á ÄÍú∞·¥ú ü ü ·¥ä·¥Ä·¥†·¥ÄÍú±·¥Ñ Ä…™·¥ò·¥õ ·¥° ú·¥Ä·¥õÍú±·¥Ä·¥ò·¥ò  ô·¥è·¥õ ...*
> *‚ô¶Ô∏è·¥è·¥°…¥·¥á Ä : 94721551183 ...*
> *‚ô¶Ô∏è·¥†·¥á ÄÍú±…™·¥è…¥ :* *1.0 ...*
> *‚ô¶Ô∏è·¥° ú·¥Ä·¥õÍú±·¥Ä·¥ò·¥ò ·¥Ñ ú·¥Ä…¥…¥·¥á ü : https://whatsapp.com/channel/0029VbAdMtMGk1G1R9Yg2L3x*

> *·¥Ñ Ä·¥á·¥Ä·¥õ·¥á·¥Ö  ô è ·¥ç·¥Ä…¥…™Íú± ú·¥Ä ·¥Ñ·¥è·¥Ö·¥á Ä*
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚óè‚ñ∫`

          // Sending the image with caption
await conn.sendMessage(from,{image: {url: config.ALIVE_IMG},caption: desc},{quoted: mek });

      } catch (e) {
          console.error(e);
          reply(`*Error:* ${e.message}`);
      }
    });



cmd({
      pattern: "menu",
      alias: ["panel"],
      desc: "Get Bot Menu",
      category: "main",
      react: "üìÅ",
      filename: __filename
}, async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
    
let menu = {
download: '',
ai: '',
main: '',
owner: '',
fun: '',
search: '',
Convert: '',
other: '',
tool: '',
movie: '',
settings: ''
};

for (let i = 0; i < commands.length; i++) {
if (commands[i].pattern && !commands[i].dontAddCommandList) {
menu[commands[i].category] += `.${commands[i].pattern}\n`;
 }
}
   

let desc = `*üëã Hello ${pushname}*
          
*‚ï≠‚îÄ„Äå ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö ·¥ò·¥Ä…¥·¥á ü „Äç*
*‚îÇ‚óà  Ä·¥ú…¥·¥õ…™·¥ç·¥á : ${runtime(process.uptime())}*
*‚îÇ‚óà  Ä·¥Ä·¥ç ·¥úÍú±·¥Ä…¢·¥á : ${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB / ${Math.round(require('os').totalmem / 1024 / 1024)}MB*
*‚îÇ‚óà ·¥ò ü·¥Ä·¥õÍú∞·¥è Ä·¥ç : ${os.hostname()}*
*‚îÇ‚óà ·¥†·¥á ÄÍú±…™·¥è…¥ : 1.0*
*‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚óè‚ñ∫*
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚óè‚ñ∫
 üì• *Download Menu*
 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 ${menu.download}
 
 üëë *Owner Menu*
 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 ${menu.owner}
 
 ü§ñ *AI Menu*
 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 ${menu.ai}
 
 üè† *Main Menu*
 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 ${menu.main}
 
 üòÑ *Fun Menu*
 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 ${menu.fun}
 
 üîç *Search Menu*
 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 ${menu.search}
 
 üîÑ *Convert Menu*
 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 ${menu.convert}
 
 üìå *Other Menu*
 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 ${menu.other}
 
 üõ†Ô∏è *Tool Menu*
 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 ${menu.tool}
 
 üé¨ *movie Menu*
 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 ${menu.movie}
 
 ‚öôÔ∏è *settings menu*
 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 ${menu.settings}
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚óè‚ñ∫

> *·¥Ñ Ä·¥á·¥Ä·¥õ·¥á·¥Ö  ô è ·¥ç·¥Ä…¥…™Íú± ú·¥Ä ·¥Ñ·¥è·¥Ö·¥á Ä*`

await conn.sendMessage(from,{image: {url: `https://files.catbox.moe/vbi10j.png`},caption: desc},{quoted: mek});

 } catch (e) {
      console.log(e);
      reply(`${e}`);
    }
  }
);

cmd({
    pattern: "system",
    react: "‚ô†Ô∏è",
    alias: ["uptime","status","runtime"],
    desc: "cheack uptime",
    category: "main",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
let status = ` *‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚óè‚ñ∫*
> *‚ô¶Ô∏è·¥ç·¥Ä…¥…™Íú± ú·¥Ä-·¥ç·¥Ö Íú± èÍú±·¥õ·¥á·¥ç*

*‚ô¶Ô∏è·¥ú·¥ò·¥õ…™·¥ç·¥á :* ${runtime(process.uptime())}

*‚ô¶Ô∏è Ä·¥Ä·¥ç ·¥úÍú±·¥Ä…¢·¥á :* ${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB / ${Math.round(require('os').totalmem / 1024 / 1024)}MB

*‚ô¶Ô∏è ú·¥èÍú±·¥õ…¥·¥Ä·¥ç·¥á :* ${os.hostname()}

> *·¥Ñ Ä·¥á·¥Ä·¥õ·¥á·¥Ö  ô è ·¥ç·¥Ä…¥…™Íú± ú·¥Ä ·¥Ñ·¥è·¥Ö·¥á Ä*
*‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚óè‚ñ∫*
`
await conn.sendMessage(from,{image:{url:config.ALIVE_IMG},caption:`${status}`},{quoted:mek})

}catch(e){
console.log(e)
reply(`${e}`)
}
})

cmd({
    pattern: "ping",
    desc: "Check bot's response time.",
    category: "main",
    react: "üöÄ",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const startTime = Date.now()
        const message = await conn.sendMessage(from, { text: '*PINGING...*' })
        const endTime = Date.now()
        const ping = endTime - startTime
        
        await conn.sendMessage(from, { text: `*üöÄMANISHA-MD SPEED : ${ping}ms*`}, { quoted: message })

    } catch (e) {
        console.log(e)
        reply(`${e}`)
    }
})

cmd({
      pattern: "runtime",
      desc: "Chek Bot Runtime",
      category: "main",
      react: "‚è∞",
      filename: __filename
    }, async (conn, mek, m, { from, reply }) => {
      try {
      
      let desc = `
      ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚óè‚ñ∫
      *üöÄ  Ä·¥ú…¥·¥õ…™·¥ç·¥á :* ${runtime(process.uptime())}
      ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚óè‚ñ∫`

          // Sending the image with caption
          await conn.sendMessage(from,{image: {url: config.ALIVE_IMG},caption: desc},{quoted: mek});
          
      } catch (e) {
          console.error(e);
          reply(`*Error:* ${e.message}`);
      }
    });
    

//================AI COMMAND===================
cmd({
  pattern: "gemini",
  alias: ["ai","chatgpt"],
  react: 'ü§ñ',
  desc: "Ask anything to Google Gemini AI.",
  category: "ai",
  use: ".gemini <Your Quoestion>",
  filename: __filename
}, async (conn, mek, msg, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
  try {
    const text = args.join(" ");
    if (!text) {
      return reply(`‚ùóÔ∏è Please GFive Me A Question`);
    }

    const prompt = `my name is ${pushname}, Your name is manisha AI. you are a WhatsApp AI Bot. you were made by ‡∂∏‡∂±‡∑í‡∑Ç coder. answer in the language the person talking to you speak. Answer in a way that doesn't sound like you're a bot. think you are human and answer. Use meaningful emojis. my question is: ${text}`;

    const payload = {
      contents: [{
        parts: [{ text: prompt }]
      }]
    };

    const response = await axios.post(
      GEMINI_API_URL,
      payload,
      {
        headers: {
          "Content-Type": "application/json",
        },
      }
    );

    if (!response.data || !response.data.candidates || !response.data.candidates[0]?.content?.parts) {
      return reply("‚ùå error in the answer. üò¢");
    }
    
    const aiResponse = response.data.candidates[0].content.parts[0].text;
    await reply(`${aiResponse}`);
  } catch (error) {
    console.error("Error:", error.response?.data || error.message);
    reply("‚ùå Error in the quation üò¢");
  }
});

//============OTHER COMMAND==================
cmd({
    pattern: "weather",
    desc: "üå§ Get weather information for a location",
    react: "üå§",
    category: "other",
    filename: __filename
},
async (conn, mek, m, { from, q, reply }) => {
    try {
        if (!q) return reply("‚ùó Please provide a city name. Usage: .weather [city name]");
        const apiKey = '2d61a72574c11c4f36173b627f8cb177'; 
        const city = q;
        const url = `http://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${apiKey}&units=metric`;
        const response = await axios.get(url);
        const data = response.data;
        const weather = `‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚óè‚ñ∫
üåç *·¥°·¥á·¥Ä·¥õ ú·¥á Ä …™…¥Íú∞·¥è Ä·¥ç·¥Ä·¥õ…™·¥è…¥ Íú∞·¥è Ä ${data.name}, ${data.sys.country}* üåç
üå°Ô∏è *·¥õ·¥á·¥ç·¥ò·¥á Ä·¥Ä·¥õ·¥ú Ä·¥á*: ${data.main.temp}¬∞C
üå°Ô∏è *Íú∞·¥á·¥á üÍú±  ü…™·¥ã·¥á*: ${data.main.feels_like}¬∞C
üå°Ô∏è *·¥ç…™…¥ ·¥õ·¥á·¥ç·¥ò*: ${data.main.temp_min}¬∞C
üå°Ô∏è *·¥ç·¥Äx ·¥õ·¥á·¥ç·¥ò*: ${data.main.temp_max}¬∞C
üíß * ú·¥ú·¥ç…™·¥Ö…™·¥õ è*: ${data.main.humidity}%
‚òÅÔ∏è *·¥°·¥á·¥Ä·¥õ ú·¥á Ä*: ${data.weather[0].main}
üå´Ô∏è *Íú±·¥áÍú±·¥Ñ Ä…™·¥ò·¥õ…™·¥è…¥*: ${data.weather[0].description}
üí® *·¥°…™…¥·¥Ö Íú±·¥ò·¥á·¥á·¥Ö*: ${data.wind.speed} m/s
üîΩ *·¥ò Ä·¥áÍú±Íú±·¥ú Ä·¥á*: ${data.main.pressure} hPa

*·¥Ñ Ä·¥á·¥Ä·¥õ·¥á·¥Ö  ô è ·¥ç·¥Ä…¥…™Íú± ú·¥Ä ·¥Ñ·¥è·¥Ö·¥á Ä*
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚óè‚ñ∫`;
        return reply(weather);
    } catch (e) {
        console.log(e);
        if (e.response && e.response.status === 404) {
            return reply("üö´ City not found. Please check the spelling and try again.");
        }
        return reply("‚ö†Ô∏è An error occurred while fetching the weather information. Please try again later.");
    }
});

cmd({
    pattern: "githubstalk",
    desc: "Fetch detailed GitHub user profile including profile picture.",
    category: "other",
    react: "üìö",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const username = args[0];
        if (!username) {
            return reply("Please provide a GitHub username.");
        }

        const apiUrl = `https://api.github.com/users/${username}`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        let userInfo = `‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚óè‚ñ∫
> *‚ô¶Ô∏è·¥ç·¥Ä…¥…™Íú± ú·¥Ä-·¥ç·¥Ö …¢…™·¥õÍú±·¥õ·¥Ä ü·¥ã*
        
üë§ *·¥úÍú±·¥á Ä …¥·¥Ä·¥ç·¥á*: ${data.name || data.login}

üîó *…¢…™·¥õ ú·¥ú ô ·¥ú Ä ü*:(${data.html_url})

üìù * ô…™·¥è*: ${data.bio || 'Not available'}

üèôÔ∏è * ü·¥è·¥Ñ·¥Ä·¥õ…™·¥è…¥*: ${data.location || 'Unknown'}

üìä *·¥ò·¥ú ô ü…™·¥Ñ  Ä·¥á·¥ò·¥è*: ${data.public_repos}

üë• *Íú∞·¥è ü ü·¥è·¥°·¥á ÄÍú±*: ${data.followers} | Following: ${data.following}

üìÖ *·¥Ñ Ä·¥á·¥Ä·¥õ Ä·¥Ö ·¥Ö·¥Ä·¥õ·¥á*: ${new Date(data.created_at).toDateString()}

üî≠ *·¥ò·¥ú ô ü…™·¥Ñ …¢…™Íú±·¥õÍú±*: ${data.public_gists}

> *·¥Ñ Ä·¥á·¥Ä·¥õ·¥á·¥Ö  ô è ·¥ç·¥Ä…¥…™Íú± ú·¥Ä ·¥Ñ·¥è·¥Ö·¥á Ä*
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚óè‚ñ∫`;

        await conn.sendMessage(from, { image: { url: data.avatar_url }, caption: userInfo }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`Error fetching dataü§ï: ${e.response ? e.response.data.message : e.message}`);
    }
});


cmd({
    pattern: "trt",
    alias: ["translate"],
    desc: "üåç Translate text between languages",
    react: "‚ö°",
    category: "other",
    filename: __filename
},
async (conn, mek, m, { from, q, reply }) => {
    try {
        const args = q.split(' ');
        if (args.length < 2) return reply("‚ùó Please provide a language code and text. Usage: .translate [language code] [text]");

        const targetLang = args[0];
        const textToTranslate = args.slice(1).join(' ');

        const url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(textToTranslate)}&langpair=en|${targetLang}`;

        const response = await axios.get(url);
        const translation = response.data.responseData.translatedText;

        const translationMessage = `
> *‚≠ïMANISHA-MD TRANSLATION ‚≠ï*

*‚≠ï·¥è Ä…™…¢…™…¥·¥Ä ü*: ${textToTranslate}

*‚≠ï·¥õ Ä·¥Ä…¥Íú± ü·¥Ä·¥õ·¥á·¥Ö*: ${translation}

*‚≠ï ü·¥Ä…¥…¢·¥ú·¥Ä…¢·¥á*: ${targetLang.toUpperCase()}

> *·¥Ñ Ä·¥á·¥Ä·¥õ·¥á·¥Ö  ô è ·¥ç·¥Ä…¥…™Íú± ú·¥Ä ·¥Ñ·¥è·¥Ö·¥á Ä*`;

        return reply(translationMessage);
    } catch (e) {
        console.log(e);
        return reply("‚ö†Ô∏è An error occurred data while translating the your text. Please try again laterü§ï");
    }
});


cmd({
    pattern: "tts",
    desc: "download songs",
    category: "other",
    react: "üëß",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if(!q) return reply("Need some text.")
    const url = googleTTS.getAudioUrl(q, {
  lang: 'hi-IN',
  slow: false,
  host: 'https://translate.google.com',
})
await conn.sendMessage(from, { audio: { url: url }, mimetype: 'audio/mpeg', ptt: true }, { quoted: mek })
    }catch(a){
reply(`${a}`)
}
})



//===================TOOL COMMAND===========
cmd({
    pattern: "gitclone",
    desc: "Download a GitHub repository as a ZIP file.",
    category: "tool",
    react: "üïäÔ∏è",
    use: "<github_link>",
    filename: __filename
}, 
async (conn, mek, m, { from, args, q, reply }) => {
    try {
        if (!q) return reply("Where is the link?\nExample:\n.gitclone repolink");

        if (!q.includes("github.com")) return reply("Invalid GitHub link!");

        let match = q.match(/(?:https|git)(?::\/\/|@)github\.com[\/:]([^\/:]+)\/(.+)/i);
        if (!match) return reply("Invalid GitHub link format!");

        let [, owner, repo] = match;
        repo = repo.replace(/.git$/, '');
        let zipUrl = `https://api.github.com/repos/${owner}/${repo}/zipball`;

        let response = await fetch(zipUrl, { method: "HEAD" });
        let filename = response.headers.get("content-disposition").match(/attachment; filename=(.*)/)[1];

        await conn.sendMessage(from, {
            document: { url: zipUrl },
            fileName: filename + ".zip",
            mimetype: "application/zip"
        }, { quoted: mek });

    } catch (error) {
        console.error("GitClone Error:", error);
        reply("An error occurred while downloading the repository.");
    }
});



//==============SEARCH COMMAND================
cmd({
    pattern: "yts",
    alias: ["ytsearch"],
    use: '.yts ',
    react: "üîé",
    desc: "Search and get details from youtube.",
    category: "search",
    filename: __filename

},

async(conn, mek, m,{from, l, quoted, body, isCmd, umarmd, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!q) return reply('*Please give me words to search*')
try {
let yts = require("yt-search")
var arama = await yts(q);
} catch(e) {
    l(e)
return await conn.sendMessage(from , { text: '*Error !!*' }, { quoted: mek } )
}
var mesaj = '';
arama.all.map((video) => {
mesaj += ' *üñ≤Ô∏è' + video.title + '*\nüîó ' + video.url + '\n\n'
});
await conn.sendMessage(from , { text:  mesaj }, { quoted: mek } )
} catch (e) {
    l(e)
  reply('*Error !!*')
}
});
cmd({
    pattern: "mvs",
    desc: "Fetch detailed information about a movie.",
    category: "search",
    react: "üé¨",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const movieName = args.join(' ');
        if (!movieName) {
            return reply("üìΩÔ∏è œÅ‚Ñì—îŒ±—ï—î œÅ—èœÉŒΩŒπ‚àÇ—î —Ç–Ω—î Œ∑Œ±–º—î œÉ∆í —Ç–Ω—î –ºœÉŒΩŒπ—î.");
        }

        const apiUrl = `http://www.omdbapi.com/?t=${encodeURIComponent(movieName)}&apikey=${config.OMDB_API_KEY}`;
        const response = await axios.get(apiUrl);

        const data = response.data;
        if (data.Response === "False") {
            return reply("üö´ Movie not found.");
        }

        const movieInfo = `
üé¨ *Movie Information* üé¨

üé• *Title:* ${data.Title}
üìÖ *Year:* ${data.Year}
üåü *Rated:* ${data.Rated}
üìÜ *Released:* ${data.Released}
‚è≥ *Runtime:* ${data.Runtime}
üé≠ *Genre:* ${data.Genre}
üé¨ *Director:* ${data.Director}
‚úçÔ∏è *Writer:* ${data.Writer}
üé≠ *Actors:* ${data.Actors}
üìù *Plot:* ${data.Plot}
üåç *Language:* ${data.Language}
üá∫üá∏ *Country:* ${data.Country}
üèÜ *Awards:* ${data.Awards}
‚≠ê *IMDB Rating:* ${data.imdbRating}
üó≥Ô∏è *IMDB Votes:* ${data.imdbVotes}
`;

        // Define the image URL
        const imageUrl = data.Poster && data.Poster !== 'N/A' ? data.Poster : config.ALIVE_IMG;

        // Send the movie information along with the poster image
        await conn.sendMessage(from, {
            image: { url: imageUrl },
            caption: `${movieInfo}\n> *·¥Ñ Ä·¥á·¥Ä·¥õ·¥á·¥Ö  ô è ·¥ç·¥Ä…¥…™Íú± ú·¥Ä ·¥Ñ·¥è·¥Ö·¥á Ä*`
        }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`‚ùå —î—è—èœÉ—è: ${e.message}`);
    }
});

//===============FUN COMMAND============
cmd({
    pattern: "animegirl",
    desc: "Fetch a random anime girl image.",
    category: "fun",
    react: "üë©‚Äçü¶∞",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const apiUrl = `https://api.waifu.pics/sfw/waifu`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        await conn.sendMessage(from, { image: { url: data.url }, caption: '*MANISHA-MD RANDOM ANIME GIRL IMAGES* ‚ô•Ô∏è\n\n\n> *·¥Ñ Ä·¥á·¥Ä·¥õ·¥á·¥Ö  ô è ·¥ç·¥Ä…¥…™Íú± ú·¥Ä ·¥Ñ·¥è·¥Ö·¥á Ä*' }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`*Error Fetching Anime girl image*: ${e.message}`);
    }
});


cmd({
    pattern: "dog",
    desc: "Fetch a random dog image.",
    category: "fun",
    react: "üê∂",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const apiUrl = `https://dog.ceo/api/breeds/image/random`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        await conn.sendMessage(from, { image: { url: data.message }, caption: 'MANISHA-MD DOWNLOAD DOG IMAGE\n\n\n> *·¥Ñ Ä·¥á·¥Ä·¥õ·¥á·¥Ö  ô è ·¥ç·¥Ä…¥…™Íú± ú·¥Ä ·¥Ñ·¥è·¥Ö·¥á Ä*' }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`Error Fetching Dog Image: ${e.message}`);
    }
});

cmd({
  pattern: "joke",
  desc: "üòÇ Get a random joke",
  react: "ü§£",
  category: "fun",
  filename: __filename
}, async (conn, m, store, { reply }) => {
  try {
    const response = await axios.get("https://official-joke-api.appspot.com/random_joke");
    const joke = response.data;

    if (!joke || !joke.setup || !joke.punchline) {
      return reply("‚ùå Failed to fetch a joke. Please try again.");
    }

    const jokeMessage = `ü§£ *Here's a random joke for you!* ü§£\n\n*${joke.setup}*\n\n${joke.punchline} üòÜ\n\n> *·¥Ñ Ä·¥á·¥Ä·¥õ·¥á·¥Ö  ô è ·¥ç·¥Ä…¥…™Íú± ú·¥Ä ·¥Ñ·¥è·¥Ö·¥á Ä*`;

    return reply(jokeMessage);
  } catch (error) {
    console.error("‚ùå Error in joke command:", error);
    return reply("‚ö†Ô∏è An error occurred while fetching the joke. Please try again.");
  }
});

cmd({
  pattern: "fact",
  desc: "üß† Get a random fun fact",
  react: "üß†",
  category: "fun",
  filename: __filename
}, async (conn, m, store, { reply }) => {
  try {
    const response = await axios.get("https://uselessfacts.jsph.pl/random.json?language=en");
    const fact = response.data.text;

    if (!fact) {
      return reply("‚ùå Failed to fetch a fun fact. Please try again.");
    }

    const factMessage = `üß† *Random Fun Fact* üß†\n\n${fact}\n\nIsn't that interesting? üòÑ\n\n> *·¥Ñ Ä·¥á·¥Ä·¥õ·¥á·¥Ö  ô è ·¥ç·¥Ä…¥…™Íú± ú·¥Ä ·¥Ñ·¥è·¥Ö·¥á Ä*`;

    return reply(factMessage);
  } catch (error) {
    console.error("‚ùå Error in fact command:", error);
    return reply("‚ö†Ô∏è An error occurred while fetching a fun fact. Please try again later.");
  }
});

cmd({
    pattern: "hack",
    desc: "Displays a dynamic and playful 'Hacking' message for fun.",
    category: "fun",
    react: "üë®‚Äçüíª",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const steps = [
            'üíª *MANISHA-MD HACK STARTING...* üíª',
            '',
            '*Initializing hacking tools...* üõ†Ô∏è',
            '*Connecting to remote servers...* üåê',
            '',
            '```[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] 10%``` ‚è≥'                                            ,
            '```[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] 20%``` ‚è≥'                                   ,
            '```[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] 30%``` ‚è≥'                               ,
            '```[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] 40%``` ‚è≥'                            ,
            '```[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] 50%``` ‚è≥'                       ,
            '```[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] 60%``` ‚è≥'                 ,
            '```[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] 70%``` ‚è≥'            ,
            '```[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] 80%``` ‚è≥'        ,
            '```[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] 90%``` ‚è≥'    ,
            '```[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] 100%``` ‚úÖ',
            '',
            'üîí *System Breach: Successful!* üîì',
            'üöÄ *Command Execution: Complete!* üéØ',
            '',
            '*üì° Transmitting data...* üì§',
            '*üïµÔ∏è‚Äç‚ôÇÔ∏è Ensuring stealth...* ü§´',
            '*üîß Finalizing operations...* üèÅ',
            '*üîß Awais Get Your All Data...* üéÅ',
            '',
            '‚ö†Ô∏è *Note:* All actions are for demonstration purposes only.',
            '‚ö†Ô∏è *Reminder:* Ethical hacking is the only way to ensure security.',
            '‚ö†Ô∏è *Reminder:* Strong hacking is the only way to ensure security.',
            '',
            ' * YOUR DATA HACK SUCCESSFULLY*'
        ];

        for (const line of steps) {
            await conn.sendMessage(from, { text: line }, { quoted: mek });
            await new Promise(resolve => setTimeout(resolve, 1000)); // Adjust the delay as needed
        }
    } catch (e) {
        console.log(e);
        reply(`‚ùå *Error!* ${e.message}`);
    }
});